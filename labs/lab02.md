# Лабороторна робота №2
# Тема: Розгалужені обчислювальні процеси
## Мета: 
 1. Вивчити особливості розгалужених обчислювальних процесів
 2. Опанувати технологію використання логічних операторів

## Умова задачі №1:
 Визначити значення функції в залежності від значення її аргументу, яке вводиться з клавіатури. 
 Умови завдання 1 (за варіантом №13): 
![image](https://github.com/user-attachments/assets/4a59ece5-101f-4e91-8222-f0511d050921)
## Умова задачі №2
Розв'язати геометричну або логічну задачу.
 Умови завдання 2 (за варіантом №13): 
![image](https://github.com/user-attachments/assets/4c965399-9f37-4405-a052-1e273a2054b2)
## Аналіз задачі та теоретичні обгрунтування вибраного методу вирішення задачі.
### Задача №1
Проект включає бібліотеки "iostream" для введення/виведення даних, "math.h" для математичних обчислень, "limits" для перевірки введення, та "numbers" для використання константи pi. Функція isNumber запитує користувача ввести число x, перевіряє введення та очищує потік у разі помилок. Функція solutionFoo визначає, яка тригонометрична функція застосовується до x залежно від його значення, та обчислює результат. В основній функції main викликаються ці функції, і результат виводиться на екран. Програма обробляє введення, перевіряє значення та обчислює результат, залежно від умов, заданих для x.
Таким чином, програма коректно обробляє введення даних, перевіряє їх на відповідність умовам та обчислює результат на основі тригонометричних функцій у різних інтервалах значення x.
### Задача №2
Проект використовує бібліотеки "iostream", "limits", та "locale" для роботи з введенням даних, їх перевірки та локалізації. Структура "point" зберігає координати точок, а функція writeCoordinate дозволяє вводити координати з перевіркою на коректність. createSquare будує квадрат на основі точки та розміру сторони, зберігаючи координати вершин у масиві. checkCrossing перевіряє перетин квадратів і виводить координати точок перетину. В основній функції main користувач вводить координати двох квадратів, які перевіряються на перетин, і програма виводить результати або запитує нове введення, якщо перетину немає.

**Зверніть увагу**, що при редагуванні та запуску коду, слід використовувати найновішу версію компілятора.
## Алгоритм у вигляді блок-схеми
### Задача №1
![image](https://github.com/user-attachments/assets/d668b6b8-61f6-4be6-94e5-33f7c0e1af16)
### Задача №2
![image](https://github.com/user-attachments/assets/caf6de0e-4924-450e-8856-6142e695ec5e)


## Код програми
### Задача №1
Код програми:
```cpp 
#include <iostream>
#include <math.h> // Підключаємо бібліотеку для роботи з математичними функціями
#include <locale> // Підключаємо бібліотеку для локалізації
#include <limits> // Підключаємо бібліотеку для роботи з обмеженнями введення
#include <numbers> // Підключаємо бібліотеку для використання математичних констант
using namespace std;

// Зберігаємо значення числа Пі
double PI = numbers::pi;

// Функція для введення числа з перевіркою коректності
double isNumber(double &xValue) {
	while (true) {
		cout << "Введiть значення х: ";
		cin >> xValue;
		// Перевіряємо, чи було введено некоректне значення
		if (cin.fail()) {
			cin.clear(); // Очищаємо стан потоку
			cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Ігноруємо некоректне введення
			cout << endl << "Значення було введено некоректне. Спробуйте ще раз...";
			system("pause"); // Зупиняємо виконання програми для зручності користувача
			system("cls"); // Очищаємо екран
		}
		else {
			break; // Виходимо з циклу, якщо введення коректне
		}
	}
	return xValue; // Повертаємо коректне значення
}

// Функція для обчислення результату залежно від значення x
void solutionFoo(double &xValue, double &Foo) {
	// Якщо x у межах від 0 до PI, застосовуємо синус
	if (0 < xValue && xValue < PI) {
		Foo = sin(xValue);
	}
	// Якщо x у межах від PI до 3/2 PI, застосовуємо косинус
	else if (PI < xValue && xValue < 3 * (PI) / 2) {
		Foo = cos(xValue);
	}
	// Якщо x у межах від 3/2 PI до 2 PI, застосовуємо тангенс
	else if (3 * (PI) / 2 < xValue && xValue < 2 * PI) {
		Foo = sin(xValue) / cos(xValue);
	}
	// Якщо x не входить у жодні з умов
	else {
		cout << endl << "Число не входить у межі(за умовою)!";
		system("pause"); // Зупиняємо виконання програми для зручності користувача
		system("cls"); // Очищаємо екран
	}
}

// Основна функція
int main() {
	setlocale(LC_CTYPE, "ukr"); // Встановлюємо українську локалізацію для підтримки українських символів
	double x, result; // Оголошуємо змінні для значення x та результату
	isNumber(x); // Викликаємо функцію для введення та перевірки значення x
	solutionFoo(x, result); // Обчислюємо результат залежно від значення x
	cout << "Кiнцевий результат рiвняння  = " << result << endl; // Виводимо результат на екран
}

```
### Задача №2
Код програми:
```cpp
#include <iostream>
#include <limits>
#include <locale>
using namespace std;

// Структура для збереження координат точки
struct point {
public:
	int x; // координата x
	int y; // координата y
	
	// Конструктор з параметрами для ініціалізації координат
	point(int value1, int value2) {
		x = value1;
		y = value2;
	}
	
	// Конструктор за замовчуванням, ініціалізує точку з координатами (0, 0)
	point() {
		x = 0;
		y = 0;
	}
	
	// Функція для виведення координат точки
	void printPoint() {
		cout << "(" << x << "," << y << ")" << endl;
	}
};

// Функція для введення координат точки з перевіркою коректності
void writeCoordinate(int xy[2]) {
	char arr[]{ 'x','y' };
	for (int i = 0; i < 2; i++) {
		while (true) {
			cout << endl << "Введiть координату " << arr[i] << ":";
			cin >> xy[i];
			// Перевіряємо на коректність введення
			if (cin.fail()) {
				cin.clear(); // Очищаємо стан потоку
				cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Ігноруємо некоректне введення
				cout << "Некоректне введення. Будь ласка, спробуйте ще раз." << endl;
			} else {
				break; // Якщо введення коректне, виходимо з циклу
			}
		}
	}
}

// Функція для створення координат квадрату
void createSquare(point po1nt, int* side, point arr[4]) {
	while (true) {
		cout << endl << "Введiть розмiр сторони квадрата: ";
		cin >> *side;
		// Перевіряємо на коректність введення
		if (cin.fail()) {
			cin.clear(); // Очищаємо стан потоку
			cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Ігноруємо некоректне введення
			cout << "Некоректне введення. Будь ласка, спробуйте ще раз." << endl;
		} else {
			break; // Введено коректне значення, виходимо з циклу
		}
	}
	// Задаємо координати вершин квадрату на основі лівої нижньої точки та розміру сторони
	arr[0] = po1nt;
	arr[1] = { po1nt.x, po1nt.y + *side };
	arr[2] = { po1nt.x + *side, po1nt.y + *side };
	arr[3] = { po1nt.x + *side, po1nt.y };
}

// Функція для виведення координат квадрату
void writeCoordSquare(point arr[4]) {
	for (int i = 0; i < 4; i++) {
		cout << endl << "Координати точки " << i + 1 << ":" << endl;
		arr[i].printPoint();
	}
}

// Функція для виведення координат перетину квадратів
void squareCrossing(int size, point arr2[], point arr1[]) {
	cout << endl << "Координати утвореного квадрату: ";
	switch (size) {
		// Виводимо координати відповідних точок залежно від індексу
		case 0:
			cout << endl << "Координати лiвої нижньої точки: (" << arr2[size].x << ";" << arr2[size].y << ")";
			cout << endl << "Координати правої верхньої точки : (" << arr1[2].x << ";" << arr1[2].y << ")";
			break;
		case 1:
			cout << endl << "Координати лiвої верхньої точки: (" << arr2[size].x << ";" << arr2[size].y << ")";
			cout << endl << "Координати правої нижньої точки: (" << arr1[3].x << ";" << arr1[3].y << ")";
			break;
		case 2:
			cout << endl << "Координати верхньої правої точки: (" << arr2[size].x << ";" << arr2[size].y << ")";
			cout << endl << "Координати лiвої нижньої точки: (" << arr1[0].x << ";" << arr1[0].y << ")";
			break;
		case 3:
			cout << endl << "Координати правої нижньої точки: (" << arr2[size].x << ";" << arr2[size].y << ")";
			cout << endl << "Координати лiвої верхньої точки : (" << arr1[1].x << ";" << arr1[1].y << ")";
			break;
		default:
			cout << endl << "ПОМИЛКА!";
	}
}

// Функція для перевірки, чи перетинаються квадрати
void checkCrossing(point arr1[4], point arr2[4], int* TorF) {
	for (int i = 0; i < 4; i++) {
		// Перевіряємо, чи точка другого квадрату знаходиться всередині першого квадрату
		if ((arr1[0].x < arr2[i].x && arr2[i].x < arr1[2].x) && (arr1[0].y < arr2[i].y && arr2[i].y < arr1[2].y)) {
			squareCrossing(i, arr2, arr1); // Викликаємо функцію для обчислення координат перетину
			*TorF = 0; // Змінюємо значення прапора для завершення циклу
			break;
		}
	}
}

// Основна функція
void main() {
	setlocale(LC_CTYPE, "ukr"); // Встановлюємо українську локалізацію
	int xy[2]; // Масив для збереження координат
	int a = 1, side, * TorF1 = &a; // Змінні для розміру сторони та контролю циклу
	point firstSquare[4]; // Масив для збереження координат першого квадрату
	point secondSquare[4]; // Масив для збереження координат другого квадрату
	
	// Цикл для введення даних і перевірки перетину квадратів
	while (*TorF1 == 1) {
		cout << "_____________________________ Перший квадрат _____________________________" << endl << "Введiть координати лiвої нижньої точки першого куба: ";
		writeCoordinate(xy); // Вводимо координати для першого квадрату
		point firstLeftDown(xy[0], xy[1]); // Створюємо точку на основі введених координат
		createSquare(firstLeftDown, &side, firstSquare); // Створюємо квадрат
		writeCoordSquare(firstSquare); // Виводимо координати квадрату
		
		cout << "_____________________________ Другий квадрат _____________________________" << endl << "Введiть координати лiвої нижньої точки другого куба: ";
		writeCoordinate(xy); // Вводимо координати для другого квадрату
		point secondLeftDown(xy[0], xy[1]); // Створюємо точку на основі введених координат
		createSquare(secondLeftDown, &side, secondSquare); // Створюємо квадрат
		writeCoordSquare(secondSquare); // Виводимо координати квадрату
		
		checkCrossing(firstSquare, secondSquare, TorF1); // Перевіряємо перетин квадратів
		if (*TorF1 == 1) {
			cout << endl << "Квадрати не перетинаються, спробуйте ще раз..." << endl;
			system("pause"); // Зупиняємо виконання програми для зручності користувача
			system("cls"); // Очищаємо екран
		}
	}
	cout << endl << "Кiнець програми!!!" << endl;
}

```
## Результат виконання програми
### Задача №1
При значенні х = 2,
![image](https://github.com/user-attachments/assets/f94881d9-bf45-484e-b58d-67f2cbcb35f2)
При значенні х = 3,
![image](https://github.com/user-attachments/assets/a3ee1477-40fc-4709-a227-1291eb0f440d)
При значенні х = 5,
![image](https://github.com/user-attachments/assets/586ba7c2-1e9d-49de-aa27-07684cc6cb21)

Також приклад результату, якщо ми введемо замість числа інший символ:
![image](https://github.com/user-attachments/assets/bf2ab19e-033a-4230-9a9d-1d2a55f71efc)

### Задача №2
Підберемо значення, щоб квадрати перетинались:
![image](https://github.com/user-attachments/assets/a76f4318-ec4b-46ba-9f56-a6e9edecc412)
та, щоб не перетинались:
![image](https://github.com/user-attachments/assets/9204c8d5-8aca-4025-bd32-a765237abd37)

Також приклад результату, якщо ми введемо замість числа інший символ:
![image](https://github.com/user-attachments/assets/9f83b80f-a9f3-40e7-b270-0a2cfefc17fb)

## Аналіз достовірності результатів
Перевіримо чи є кінцевий результат задач вірним. Для цього використаймо калькулятор "Photomath"
### Задача №1
Візьмемо для прикладу такі значення:
A = 5, B = 1, C = 9, D = 13
![photo_2_2024-09-22_17-28-02](https://github.com/user-attachments/assets/0e229fc5-3f07-40aa-aca5-80780dd1155d)
### Задача №2
Візьмемо для прикладу таке значення:
х = 2;
![photo_3_2024-09-22_17-28-02](https://github.com/user-attachments/assets/b568cc07-0c4d-48de-8e95-5da47f1542d9)
x^9;
![photo_1_2024-09-22_17-28-02](https://github.com/user-attachments/assets/a9ffb8c0-8b9e-4aac-b855-ff87a3766cf4)
x^15.

Як ми можемо побачити результати двох задач сходяться з розрахунками калькулятора.
## Висновок
Під час лабороторної роботи я:
• Опанував базові навички мови програмування С++;

• Вивчив особливості використання  вбудованих типів даних: char,  int,  long, short, float, double, unsigned char, unsigned int, unsigned long;

• Вивчив особливості використання функцій введення - виведення;

• Навчився застосовувати стандартні математичні функції;

• Створив профіль на Github та навчився створювати та прикрипляти файли до нього.
