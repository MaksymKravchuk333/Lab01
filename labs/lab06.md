# Лабороторна робота №6
# Тема: Одновимірні масиви
## Мета: 
 1. Ознайомитися з особливостями типу масиву;
 2. Опанувати технологію застосування масивів даних;
 3. Навчитися розробляти алгоритми та програми із застосуванням одновимірних масивів
## Загальні умови до виконання умов:
Завдання 1. Використання базових операцій обробки одновимірних масивів
    Передбачити вибір способу створення масиву:
    - введення з клавіатури;
    - заповнення масиву псевдовипадковими числами.
    Умови завдання 1 подані у таблиці 6.1.
Забороняється використовувати бібліотеку стандартних шаблонів STL і шаблон вектору std::vector

Завдання 2. Алгоритми сортування та пошуку
      - визначити ефективність методу сортування: кількість порівнянь та обмінів;
      - визначити ефективність методу пошуку: кількість порівнянь;
      - передбачити вибір режиму виведення результатів: або тільки відсортований масив, або з проміжними ітераціями.
     Умови завдання 2 подані в таблиці 6.1.
Забороняється використовувати бібліотеку стандартних шаблонів STL, шаблон вектору std::vector, а також бібліотечні методи сортування та пошуку.

Завдання 3. Векторна алгебра, поліноми, многочлени, алгебраїчні рівняння
     Умови завдання 3 подані в таблиці 6.1.
Забороняється використовувати бібліотеку стандартних шаблонів STL, шаблон вектору std::vector, а також бібліотечні методи.

УВАГА! Не виконання умов, визначених в пунктах "Завдання 1","Завдання 2", "Завдання 3" неприпустимо і призводить до штрафних санкцій у 50% зниження балів

Застосування покажчиків, динамічних масивів, операторів new, delete в лабораторній роботі №6
НЕДОЦІЛЬНО і НЕ СХВАЛЮЄТЬСЯ!!
## Умова задачі №1:
  1. Створити одновимірний масив цілих чисел, кількість елементів якого ввести з клавіатури. Передбачити меню вибору способу створення масиву: введення з клавіатури або генерація псевдовипадкових чисел. Знайти найбільший серед від’ємних та найменший серед додатних елементів масиву. Вивести масив, значення знайдених елементів та їх індекси.
## Умова задачі №2:
  2. Створити одновимірний масив, кількість елементів якого ввести з клавіатури. Передбачити меню вибору способу створення масиву: введення з клавіатури або генерація псевдовипадкових чисел. Відсортувати масив за алгоритмом Мавп'ячого сортування (Bogosort) [1.13] та здійснити пошук в масиві за алгоритмом з мультиплікативним критерієм [2.13]. Передбачити виведення проміжних результатів в процесі виконання ітерацій сортування масиву.
## Умова задачі №3:
  3. На двовимірної площині задано n >2 точок з координатами (X1, Y1), (X2, Y2), ..., (Xn, Yn). Написати програму, яка з цих точок визначає вершини квадрата, що містить максимальну кількість заданих точок. Кількість точок n та їх координати ввести з клавіатури. Вивести на екран коорднати вершин шуканого квадрата та максимальну кількість точок.

## Аналіз задачі та теоретичні обгрунтування вибраного методу вирішення задачі:
## Завдання 1:
Ця програма реалізує роботу з одновимірним масивом цілих чисел для знаходження найбільшого негативного елемента і найменшого позитивного елемента. Бібліотека використовується<iostream>для введення та виведення даних,<Windows.h>для налаштування кодування за допомогою функції SetConsoleOutputCP(1251) та<ctime>для генерації псевдовипадкових чисел. функція welcome () виводить інформацію про завдання, функція enterArraySize () - для перевірки правильності введення розміру масиву, функція fillArray () - для можливості заповнення масиву вручну або за допомогою генератора випадкових чисел; функція checkValue () - для аналізу масиву з метою пошуку потрібного значення і функція Printtarray () - для відображення масив на екрані. Функція Main () управляє виконанням всіх операцій. Використання функціонального підходу робить код зрозумілим, ефективним і легко масштабованим.
## Завдання 2:
Програма працює з одновимірними масивами цілих чисел і реалізує сортування та пошук за мультиплікативними критеріями. Бібліотека<iostream>використовується для введення та виведення,<ctime>використовується для генерації випадкових чисел, а<Windows.h>використовується для встановлення кодування за допомогою SetConsoleOutputCP(1251).

Функція Welcome() виводить інформацію про завдання, і ви можете використовувати функцію enter Array Size () для введення розміру масиву під час перевірки точності. Функція FillArray () гарантує, що масив вводиться вручну або з випадковим числом від -100 до 100. Функція bogosort () виконує випадкове сортування масиву і відображає проміжний стан, поки він не буде приведений в порядок. Перевірка порядку виконується за допомогою isSorted ().

Функція MultiplicativeSearch () знаходить елементи, рівні ключу, помноженому на 2, шляхом підрахунку кількості порівнянь. У програмі представлені основні алгоритми маніпулювання масивами, а також підходи до рандомізації та пошуку.
## Завдання 3:
Програма виконує пошук квадратів на площині, що містять максимальну кількість заданих точок. Бібліотека<iostream>використовується для роботи з вводом-виводом,<cmath>- для математичних операцій, а<Windows.h>- для встановлення кодування за допомогою SetConsoleOutputCP(1251).

Функція Welcome () виводить інформацію про завдання. Координати точок вводяться за допомогою функції inputPoints (), і кожна точка зберігається в структурі точок з полями x і y.

Функція is Point Inside Square () перевіряє, чи належить точка квадрату, визначеному верхньою лівою вершиною та довжиною сторони. Основна логіка зосереджена у функції findsquarewithmaxpoints (), яка перебирає всі пари точок, визначає можливі квадрати та підраховує кількість цих точок. Якщо знайдений квадрат з великою кількістю точок, його параметри зберігаються.

В результаті відображаються координати вершин квадрата з максимальною кількістю точок, і виводиться повідомлення, якщо такий квадрат не знайдений.
## Алгоритм у вигляді блок-схеми:
прікриплено у гугл диску
## Код програми:
## Завдання 1:
```cpp
#include <iostream>
#include <Windows.h>
#include <ctime>   
using namespace std;
//Функція для ознайомлення з завданням
void welcome()
{
    cout << "Kravchuk Maksym Mykolayovich IPZ-14, 9 group lab6 task1 var13" << endl;
    cout << string(70, '=') << endl;
    cout << "Створити одновимірний масив цілих чисел, кількість елементів якого ввести з клавіатури.\n"
        << "Передбачити меню вибору способу створення масиву: введення з клавіатури або генерація псевдовипадкових чисел.\n"
        << "Знайти найбільший серед від’ємних та найменший серед додатних елементів масиву.\n"
        << "Вивести масив, значення знайдених елементів та їх індекси.\n";
    cout << string(70, '=') << endl;
}
int maxValue = -100;
int minValue = 100;
//Функція для заповнення масиву
void fillArray(int array[], int n)
{   
    while(true){
        int way;
        cout << "Оберіть спосіб заповнення масиву:\n";
        cout << "Щоб ввести дані з клавіатури, впишіть 1\n";
        cout << "Щоб заповнити масив псевдовипадковими числами, вишіть 2:\n";
        cin >> way;

        if (way == 1)
        {
            //Заповнення масиву вручну
            for (int i = 0; i < n; ++i)
            {
                cout << "Введіть значення " << i + 1 << ": ";
                cin >> array[i];
            }
            break;
        }
        else if (way == 2)
        {
            //Заповнення масиву випадковими числами від 1 до 100
            srand((time(NULL))); //Ініціалізація генератора випадкових чисел
            for (int i = 0; i < n; ++i)
            {
                array[i] = (rand() % 201) -100; // генерація числ від -100 до 100
            }
            break;
        }
        else
        {
            cout << "Невірний вибір, введіть 2 або 1!" << endl;
        }
    }
}
int enterArraySize()
{
    bool onnOff = true;
    int n;
    while (onnOff) {
        cout << "Введіть кількість елементів масиву: ";
        cin >> n;
        if (n > 50) {
            cout << endl << "Розмір масиву повинен бути більше за 50, спробуйте ща раз... " << endl;
        }
        else {
            //Повертає -1, якщо розмір масиву поза допустимими межами
            onnOff = false;
            return (n >= 1 && n <= 100) ? n : -1;
        }
    }
} 
// Функція для перевірки найбліьшного від'ємного та найменшого додатнього числа
void checkValue(const int array[],const int n) {
    for (int i = 0; i < n; ++i)
    {
        if (array[i] < 0)
        {
                if (array[i]>maxValue) {
                    maxValue = array[i];
                }
        }
        else if (array[i] > 0)
        {  
                if (array[i] < minValue) {
                    minValue = array[i];
                }

        }
        else {
        }
    }
}
//Функція для виведення масиву на екран
void printttArray(const int array[], const int n)
{
    for (int i = 0; i < n; ++i)
    {
        cout << array[i] << " ";
    }
    cout << endl;
}
int main() {
	SetConsoleOutputCP(1251);
    welcome();
    int array[100];
    int n = enterArraySize();
    fillArray(array, n);
    printttArray(array, n);
    checkValue(array, n);
    cout << "Найбільше від'ємне число = " << maxValue << "\t" << "Найменше додатнє число = " << minValue << endl;
    //Функція для введення розміру масиву
}
```
## Завдання 2:
```cpp
#include <iostream>
#include <ctime>
#include <Windows.h>
using namespace std;

// Функція для виведення привітання та опису завдання
void welcome() {
    cout << "Kravchuk Maksym Mykolayovich IPZ-14, 9 group lab6 task1 var13" << endl;
    cout << string(70, '=') << endl;
    cout << "Завдання:\n"
        << "- Створення та заповнення одновимірного масиву.\n"
        << "- Сортування методом Bogosort з проміжними результатами.\n"
        << "- Пошук за мультиплікативним критерієм.\n";
    cout << string(70, '=') << endl;
}

// Функція для введення розміру масиву
int enterArraySize() {
    int n;
    cout << "Введіть кількість елементів масиву (від 1 до 50): ";
    cin >> n;
    return (n > 0 && n <= 50) ? n : -1; // Перевірка на коректність розміру
}

// Функція для заповнення масиву
void fillArray(int array[], int n) {
    int choice;
    cout << "Оберіть спосіб заповнення масиву:\n1. Введення з клавіатури\n2. Заповнення випадковими числами\nВаш вибір: ";
    cin >> choice;

    if (choice == 1) {
        for (int i = 0; i < n; ++i) {
            cout << "Введіть значення елемента " << i + 1 << ": ";
            cin >> array[i];
        }
    }
    else if (choice == 2) {
        srand((unsigned)time(0));
        for (int i = 0; i < n; ++i) {
            array[i] = (rand() % 201) - 100; // Випадкові значення від -100 до 100
        }
    }
    else {
        cout << "Невірний вибір!" << endl;
    }
}

// Функція для перевірки, чи масив відсортований
bool isSorted(int array[], int n) {
    for (int i = 1; i < n; i++) {
        if (array[i - 1] > array[i]) return false;
    }
    return true;
}

// Функція сортування методом Bogosort з підрахунком кількості перестановок
void bogosort(int array[], int n) {
    int shuffleCount = 0;
    while (!isSorted(array, n)) {
        for (int i = 0; i < n; ++i) {
            int randomIndex = rand() % n;
            swap(array[i], array[randomIndex]);
        }
        shuffleCount++;

        // Виведення поточного стану масиву після кожного перемішування
        cout << "Ітерація " << shuffleCount << ": ";
        for (int i = 0; i < n; i++) cout << array[i] << " ";
        cout << endl;
    }
    cout << "Відсортований масив методом Bogosort за " << shuffleCount << " ітерацій.\n";
}

// Функція для пошуку з мультиплікативним критерієм
int multiplicativeSearch(const int array[], int n, int key) {
    int comparisons = 0;
    for (int i = 0; i < n; ++i) {
        comparisons++;
        if (array[i] * 2 == key) {
            cout << "Кількість порівнянь для пошуку: " << comparisons << endl;
            return i;
        }
    }
    cout << "Кількість порівнянь для пошуку: " << comparisons << endl;
    return -1;
}

// Основна функція
int main() {
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);

    welcome();

    int array[50];
    int n = enterArraySize();
    if (n == -1) {
        cout << "Невірна кількість елементів!" << endl;
        return 1;
    }

    fillArray(array, n);
    cout << "Початковий масив: ";
    for (int i = 0; i < n; ++i) cout << array[i] << " ";
    cout << endl;

    cout << "\nСортування методом Bogosort з проміжними результатами:\n";
    bogosort(array, n);

    int key;
    cout << "\nВведіть ключ для пошуку (2 * ключ): ";
    cin >> key;

    int index = multiplicativeSearch(array, n, key);
    if (index != -1) {
        cout << "Елемент знайдено на позиції: " << index + 1 << endl;
    }
    else {
        cout << "Елемент не знайдено!" << endl;
    }

    return 0;
}
```
## Завдання 3:
``` cpp
#include <iostream>
#include <cmath>
#include <Windows.h>

using namespace std;

// Функція для вітання та опису завдання
void welcome() {
    cout << "Kravchuk Maksym Mykolayovich IPZ-14, 9 group lab6 task2 var13" << endl;
    cout << string(70, '=') << endl;
    cout << "Завдання: На площині визначити квадрат, що містить максимальну кількість точок із заданих.\n";
    cout << string(70, '=') << endl;
}

// Структура для представлення координат точок
struct Point {
    int x, y;
};

// Функція для введення координат точок
void inputPoints(Point points[], int n) {
    for (int i = 0; i < n; ++i) {
        cout << "Введіть координати точки " << i + 1 << " (x y): ";
        cin >> points[i].x >> points[i].y;
    }
}

// Функція для перевірки, чи точка знаходиться всередині квадрата
bool isPointInsideSquare(Point p, Point topLeft, int sideLength) {
    return (p.x >= topLeft.x && p.x <= topLeft.x + sideLength &&
        p.y >= topLeft.y && p.y <= topLeft.y + sideLength);
}

// Функція для знаходження квадрата з максимальною кількістю точок
void findSquareWithMaxPoints(Point points[], int n) {
    int maxPoints = 0;
    Point bestTopLeft;
    int bestSideLength = 0;

    // Перебір можливих квадратів
    for (int i = 0; i < n; ++i) {
        for (int j = i + 1; j < n; ++j) {
            int sideLength = abs(points[j].x - points[i].x);

            if (sideLength == 0) continue; // Пропуск квадратів з нульовою довжиною

            Point topLeft = points[i];
            int count = 0;

            for (int k = 0; k < n; ++k) {
                if (isPointInsideSquare(points[k], topLeft, sideLength)) {
                    count++;
                }
            }

            // Оновлення кращого результату
            if (count > maxPoints) {
                maxPoints = count;
                bestTopLeft = topLeft;
                bestSideLength = sideLength;
            }
        }
    }

    // Виведення результату
    if (maxPoints > 0) {
        cout << "Координати вершин квадрата з максимальною кількістю точок (" << maxPoints << " точок):\n";
        cout << "(" << bestTopLeft.x << ", " << bestTopLeft.y << ")\n";
        cout << "(" << bestTopLeft.x + bestSideLength << ", " << bestTopLeft.y << ")\n";
        cout << "(" << bestTopLeft.x << ", " << bestTopLeft.y + bestSideLength << ")\n";
        cout << "(" << bestTopLeft.x + bestSideLength << ", " << bestTopLeft.y + bestSideLength << ")\n";
    }
    else {
        cout << "Квадрат, що містить точки, не знайдено.\n";
    }
}

// Основна функція
int main() {
    SetConsoleOutputCP(1251); // Для коректного виведення кирилиці на консолі

    welcome(); // Вітання

    int n;
    cout << "Введіть кількість точок (n > 2): ";
    cin >> n;

    // Перевірка на коректність введення
    if (n <= 2) {
        cout << "Кількість точок має бути більше 2!" << endl;
        return 1;
    }

    // Статичний масив з максимальною кількістю точок
    Point points[100]; // Обмежуємо максимальну кількість точок до 100

    inputPoints(points, n); // Введення координат точок
    findSquareWithMaxPoints(points, n); // Пошук квадрата з максимальною кількістю точок

    return 0;
}
```
## Результат виконання програми
## Завдання 1:
![image](https://github.com/user-attachments/assets/5ee0f54b-0ad0-4417-acb5-9fe54cc3bc41)

## Завдання 2:
![image](https://github.com/user-attachments/assets/8f451485-e23c-451b-bea3-f520fcf7744c)
## Завдання 3:
![Uploading image.png…]()

## Аналіз достовірності результатів

Як ми можемо побачити результати двох задач сходяться з розрахунками.
## Висновок
Під час лабороторної роботи я:
Вивчив особливості циклічних обчислювальних процесів з розгалуженнями
Опанував технологію рекурентних обчислень
Навчився розробляти алгоритми та програми розвинення функцій у ряди

