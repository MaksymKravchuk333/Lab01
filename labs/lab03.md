# Лабороторна робота №3
# Тема: Циклічні обчислювальні процеси
## Мета: 
 1.Вивчити особливості циклічних обчислювальних процесів
 2. Опанувати технологію використання операторів циклів
 3. Навчитися розробляти алгоритми та програми циклічних процесів

## Умова задачі №1:
## Інструкція до написання програми лабораторної роботи №3
1. Для розрахунку першої суми з параметром від 1 до 5 використати цикл for .
2. Для розрахунку внутрішньої суми з параметром від 0 до нескінченності використати цикл while або do... while.
3. Для визначення нескінченності потрібно задати точність розрахунку значення поточного элементу ряду. Підсумовування припиняється, якщо досягнута задана користувачем точність розрахунку
4. Кількість доданків внутрішньої суми для кожного параметра зовнішньої суми має бути різною.
5. Розрахунок факторіалу та степені числа виконувати, використовуючи рекурентні співвідношення
6. Для запобігання переповнення (overflow ) комірки RAM здійснити вихід із внутрішнього циклу при досягненні значення поточного элементу ряду 10^-38 або 10^+38
7. Результат подати у вигляді таблиці із чотирма колонками, що визначають параметри зовнішньої та внутрішньої сум, значення члена ряду та накопичувану суму відповідно до зразка результату роботи програми, що поданий на вкладці "Виконання прикладу"
## Рівняння:
![image](https://github.com/user-attachments/assets/fa139c5e-8abc-4cda-9cc0-46f945ecae05)
## Аналіз задачі та теоретичні обгрунтування вибраного методу вирішення задачі.
### Задача №1
Під час створення проекту було підключено iostream, cmath, iomanip та Windows.h для роботи з введенням/виведенням, математичними операціями та форматуванням тексту. Також було створено функцію welcome() виводить ідентифікаційні дані розробника та опис завдання. Вона інформує про лабораторну роботу №3, варіант 13, та формулу для обчислення. Функція power() було створена для того, щоб реалізувати рекурсивне піднесення до степеня, враховуючи від’ємні експоненти. Функція innerSum() обчислює внутрішню суму для заданого x та k, включаючи перевірку на переповнен
**Зверніть увагу**, що при редагуванні та запуску коду, слід використовувати найновішу версію компілятора. І в основній функції main() ініціалізується консоль для кирилиці, виводиться привітання, отримується значення kMax, та запускається обчислення. Програма виводить таблицю з результатами для кожного x і k, в якій кожен рядок показує обчислене значення члена ряду та накопичену суму. Наприкінці відображається загальна сума обчислених значень ряду.
## Алгоритм у вигляді блок-схеми:
![image](https://github.com/user-attachments/assets/d668b6b8-61f6-4be6-94e5-33f7c0e1af16)

## Код програми:
```cpp
#include <iostream>
#include <iomanip>
#include <cmath>
#include <Windows.h>

using namespace std;

void welcome()
{
    cout << "Lab work 3, var 13, developer Maksym Kravcuk, gr. IPZ-14" << endl;
    cout << "e-mail: maksymkravchuk333@gmail.com" << endl;
    cout << "===============================================" << endl;
    cout << "To calculate the sum of row" << endl;
    cout << "external sum for x from 1 to 5" << endl;
    cout << "internal sum for k from 0 to infinity" << endl;
    cout << "The formula includes exponentiation and factorials" << endl;
    cout << "x=5 inf" << endl;
    cout << "sum   sum  (-1)^k * x^k / (k*3 + k*sqrt(x+1))" << endl;
    cout << "x=1  k=0" << endl;
    cout << "===============================================" << endl;
}

float power (float base, int exp) {
    // Базовий випадок: будь-яке число в степені 0 дорівнює 1
    if (exp == 0) return 1;

    // Якщо показник від'ємний, повертаємо обернене значення
    if (exp < 0) return 1 / power(base, -exp);

    // Рекурсивний випадок: base^exp = base * base^(exp - 1)
    return base * power(base, exp - 1);
}

int main()
{
    welcome();
    SetConsoleOutputCP(1251); // Для коректного відображення кирилиці в консолі
    int accuracy;
    cout << "Введіть точність розрахунку внутрішньої суми: " << endl;
    cin >> accuracy;

    cout << setw(5) << "x" << setw(5) << "k" << setw(15) << "term" << setw(15) << "sum" << endl;
    float maxValueK = pow(10, 38);
    float minValueK = pow(10, -38);
    float sum = 0;
    for (int x = 1; x <= 5; x++)
    {
        int k = 0;
        int accuracyForWhile = accuracy + (x - 1);
            do {
                float term;
                float denominator = k * 3 + k * sqrt(x + 1);
                float numerator = power(-1, k) * power(x, k);
                if (denominator == 0) {
                    term = 0;
                }
                else {
                    term = numerator / denominator;
                }
                float termCheck = abs(term);
                if (termCheck > minValueK || termCheck < maxValueK) {
                    sum += term;
                    cout << setw(5) << x << setw(5) << k << setw(17) << term << setw(17) << sum << endl;
                    ++k;
                }
                else{
                    cout << "overflow float member - break cycle  with k" <<endl;
                    ++k;
                    break;
            }
        } while (k < accuracyForWhile+1);
            cout << "----------------------------------------------------------------" << endl;
    }

    return 0;
}

```
## Результат виконання програми
### Задача №1
При значенні х = 2

![image](https://github.com/user-attachments/assets/f94881d9-bf45-484e-b58d-67f2cbcb35f2)

При значенні х = 3.5

![image](https://github.com/user-attachments/assets/23b53df0-2b06-4875-83f7-fb75d57e9814)


При значенні х = 5

![image](https://github.com/user-attachments/assets/586ba7c2-1e9d-49de-aa27-07684cc6cb21)

Також приклад результату, якщо ми введемо замість числа інший символ:

![image](https://github.com/user-attachments/assets/bf2ab19e-033a-4230-9a9d-1d2a55f71efc)

### Задача №2
Підберемо значення, щоб квадрати перетинались:

![image](https://github.com/user-attachments/assets/ab8f1589-c2e4-4551-abb7-9289e7da62e0)

та, щоб не перетинались:

![image](https://github.com/user-attachments/assets/9204c8d5-8aca-4025-bd32-a765237abd37)

Також приклад результату, якщо ми введемо замість числа інший символ:

![image](https://github.com/user-attachments/assets/9f83b80f-a9f3-40e7-b270-0a2cfefc17fb)

## Аналіз достовірності результатів
Перевіримо чи є кінцевий результат задач вірним. Для цього використаймо калькулятор "Photomath"
### Задача №1
Візьмемо для прикладу такі значення, та відразу перевіривши умови, підставимо у відповідну умову:
x = 2

![image](https://github.com/user-attachments/assets/7856397f-d312-4632-852c-e5f5a0afa2fa)

x = 3.5

![image](https://github.com/user-attachments/assets/e5da8da9-f928-4a02-83e8-807e2265bddf)

x = 5

![image](https://github.com/user-attachments/assets/8d3aeea6-7be1-436f-a01e-650bf9439968)

### Задача №2
Візьмемо для прикладу такі значення, коли квадрати перетинаються:
Координати першої точки (0;0) та відстань між точками = 4,
Координати другої точки (-2;-2) та відстань між точками = 4,

![image](https://github.com/user-attachments/assets/10158504-5c09-439a-bc7b-25a8c09feb2e)

Візьмемо для прикладу такі значення, коли квадрати не перетинаються:
Координати першої точки (4;4) та відстань між точками = 4,
Координати другої точки (0;0) та відстань між точками = 2,

![image](https://github.com/user-attachments/assets/e195f25e-bde0-4494-8bc6-0c58ebfe1abe)

Як ми можемо побачити результати двох задач сходяться з розрахунками.
## Висновок
Під час лабороторної роботи я:

 Вивчив особливості розгалужених обчислювальних процесів

 Опанувати технологію використання логічних операторів

Дізнався більше про біблотеки, які були використанні піл час лабороторної роботи
